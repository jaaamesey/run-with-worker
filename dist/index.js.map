{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Runs the provided function in an ephemeral, single-purpose worker.\n * If your function needs to make asynchronous calls, try `runInWorkerCallback` instead.\n */\nexport async function runWithWorker<T, D extends Readonly<[...any]>>(\n  /**\n   * Function to run with the worker.\n   * Should adhere to the following rules:\n   * - must return a serializable value (e.g. no `Promise`s or functions)\n   * - must not read values from outside scope - use `deps` to pass these down instead\n   * - must otherwise be legal code to run inside a Worker (e.g. no DOM operations)\n   */\n  func: (...deps: D) => T,\n  /**\n   * Dependencies from outside to pass down into the function.\n   * Must be serializable.\n   */\n  deps?: Readonly<[...D]>,\n  opts?: { workerOptions?: WorkerOptions; importUrl?: string },\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const url = new URL(\n      URL.createObjectURL(\n        new Blob([\"onmessage = (m) => postMessage(new Function(m.data)())\"]),\n      ),\n      opts?.importUrl,\n    );\n    const worker = new Worker(url, opts?.workerOptions);\n    const funcStr = `return (${func.toString()})(${\n      deps ? `...${JSON.stringify(deps)}` : \"\"\n    })`;\n    worker.onmessage = (m) => {\n      resolve(m.data);\n      worker.terminate();\n    };\n    worker.onerror = (e) => {\n      reject(e);\n      worker.terminate();\n    };\n    worker.onmessageerror = (e) => {\n      reject(e);\n      worker.terminate();\n    };\n    worker.postMessage(funcStr);\n  });\n}\n\n/**\n * Same as `runWithWorker`, but for functions that make asynchronous calls.\n * Requires `func` to call `resolve` or `reject` instead of directly returning a result.\n */\nexport async function runWithWorkerCallback<T, D extends Readonly<[...any]>>(\n  func: (\n    resolve: (r: T) => void,\n    reject: (e: unknown) => void,\n    deps: D,\n  ) => void,\n  deps?: Readonly<[...D]>,\n  opts?: { workerOptions?: WorkerOptions; importUrl?: string },\n): Promise<T> {\n  const url = new URL(\n    URL.createObjectURL(\n      new Blob([\"onmessage = (m) => ((new Function(m.data))())\"]),\n    ),\n    opts?.importUrl,\n  );\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url, opts?.workerOptions);\n    const funcStr = `(${func.toString()})(r => postMessage(r), e => {throw e}, ${JSON.stringify(deps ?? [])})`;\n    worker.onmessage = (m) => {\n      resolve(m.data);\n      worker.terminate();\n    };\n    worker.onerror = (e) => {\n      reject(e);\n      worker.terminate();\n    };\n    worker.onmessageerror = (e) => {\n      reject(e);\n      worker.terminate();\n    };\n    worker.postMessage(funcStr);\n  });\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,SAAsB,cAQpB,MAKA,MACA,MACY;AAAA;AACZ,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,MAAM,IAAI;AAAA,QACd,IAAI;AAAA,UACF,IAAI,KAAK,CAAC,wDAAwD,CAAC;AAAA,QACrE;AAAA,QACA,6BAAM;AAAA,MACR;AACA,YAAM,SAAS,IAAI,OAAO,KAAK,6BAAM,aAAa;AAClD,YAAM,UAAU,WAAW,KAAK,SAAS,CAAC,KACxC,OAAO,MAAM,KAAK,UAAU,IAAI,CAAC,KAAK,EACxC;AACA,aAAO,YAAY,CAAC,MAAM;AACxB,gBAAQ,EAAE,IAAI;AACd,eAAO,UAAU;AAAA,MACnB;AACA,aAAO,UAAU,CAAC,MAAM;AACtB,eAAO,CAAC;AACR,eAAO,UAAU;AAAA,MACnB;AACA,aAAO,iBAAiB,CAAC,MAAM;AAC7B,eAAO,CAAC;AACR,eAAO,UAAU;AAAA,MACnB;AACA,aAAO,YAAY,OAAO;AAAA,IAC5B,CAAC;AAAA,EACH;AAAA;AAMA,SAAsB,sBACpB,MAKA,MACA,MACY;AAAA;AACZ,UAAM,MAAM,IAAI;AAAA,MACd,IAAI;AAAA,QACF,IAAI,KAAK,CAAC,+CAA+C,CAAC;AAAA,MAC5D;AAAA,MACA,6BAAM;AAAA,IACR;AACA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,SAAS,IAAI,OAAO,KAAK,6BAAM,aAAa;AAClD,YAAM,UAAU,IAAI,KAAK,SAAS,CAAC,0CAA0C,KAAK,UAAU,sBAAQ,CAAC,CAAC,CAAC;AACvG,aAAO,YAAY,CAAC,MAAM;AACxB,gBAAQ,EAAE,IAAI;AACd,eAAO,UAAU;AAAA,MACnB;AACA,aAAO,UAAU,CAAC,MAAM;AACtB,eAAO,CAAC;AACR,eAAO,UAAU;AAAA,MACnB;AACA,aAAO,iBAAiB,CAAC,MAAM;AAC7B,eAAO,CAAC;AACR,eAAO,UAAU;AAAA,MACnB;AACA,aAAO,YAAY,OAAO;AAAA,IAC5B,CAAC;AAAA,EACH;AAAA;","names":[]}